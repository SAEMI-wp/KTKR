from django.shortcuts import render, redirect, get_object_or_404
from django.views.generic import TemplateView, CreateView, UpdateView
from django.contrib.auth.mixins import LoginRequiredMixin
from django.contrib.auth import authenticate, login, logout, update_session_auth_hash
from django.contrib.auth.decorators import login_required
from django.contrib import messages
from django.http import JsonResponse, HttpResponse, HttpResponseBadRequest
from django.views.decorators.csrf import csrf_exempt
from django.views.decorators.http import require_http_methods, require_POST
from django.utils.decorators import method_decorator
from django.views import View
from django.urls import reverse_lazy
from django.contrib.auth.forms import AuthenticationForm
from django.utils import timezone
from datetime import datetime, date
import calendar
import json
import tempfile
from django.core.mail import EmailMessage
from django import forms

from .models import Employee, AttendanceMonthly, AttendanceDaily, HolidayCalendar
import collections
from .forms import MonthlyAttendanceForm, DailyAttendanceForm #, SignupForm
from .excel_generator import ExcelReportGenerator
from .pdf_generator import PDFReportGenerator
from .utils import get_or_create_monthly_structure, update_monthly_from_structure
from .structures import DailyData
from .cache_utils import get_monthly_data_with_cache, preload_adjacent_months, invalidate_monthly_cache, get_monthly_attendance, set_monthly_attendance

# カレンダーの最初の曜日を日曜日に設定
calendar.setfirstweekday(calendar.SUNDAY)

# ログインビュー
def login_view(request):
    if request.user.is_authenticated:
        return redirect('attendance:main')
    
    from django import forms
    from django.contrib.auth import authenticate
    
    class EmployeeAuthenticationForm(forms.Form):
        employee_no = forms.CharField(label='社員番号', max_length=6)
        password = forms.CharField(label='パスワード', widget=forms.PasswordInput)
        
        def __init__(self, request=None, *args, **kwargs):
            self.request = request
            self.user_cache = None
            super().__init__(*args, **kwargs)
        
        def clean(self):
            employee_no = self.cleaned_data.get('employee_no')
            password = self.cleaned_data.get('password')
            if employee_no and password:
                self.user_cache = authenticate(self.request, employee_no=employee_no, password=password)
                if self.user_cache is None:
                    raise forms.ValidationError('社員番号またはパスワードが正しくありません。')
            return self.cleaned_data
        
        def get_user(self):
            return self.user_cache
    
    if request.method == 'POST':
        form = EmployeeAuthenticationForm(request, data=request.POST)
        if form.is_valid():
            user = form.get_user()
            if user is not None:
                login(request, user)
                next_url = request.GET.get('next', 'attendance:main')
                return redirect(next_url)
    else:
        form = EmployeeAuthenticationForm()
    
    return render(request, 'attendance/login.html', {'form': form})

# ログアウトビュー
@login_required
def logout_view(request):
    logout(request)
    return redirect('attendance:login')

# メインビュー（ログイン必須）
class MainView(LoginRequiredMixin, TemplateView):
    template_name = 'attendance/main.html'
    login_url = 'attendance:login'
    
    def get_context_data(self, **kwargs):
        import calendar  # 함수 맨 위에서 항상 import
        context = super().get_context_data(**kwargs)
        
        # URLパラメータから年月を取得
        year = self.request.GET.get('year')
        month = self.request.GET.get('month')
        
        if year is None or month is None:
            # 오늘 날짜로 기본값 설정
            today = datetime.today()
            year = today.year
            month = today.month
        else:
            year = int(year)
            month = int(month)
        
        current_date = date(year, month, 1)
        context['current_date'] = current_date
        context['today'] = date.today()
        
        # default_day 계산
        today = date.today()
        if current_date.year == today.year and current_date.month == today.month:
            default_day = today.day
        elif current_date < today.replace(day=1):
            # 과거달: 마지막일
            last_day = calendar.monthrange(current_date.year, current_date.month)[1]
            default_day = last_day
        else:
            # 미래달: 1일
            default_day = 1
        context['default_day'] = default_day
        
        # 캐싱을 사용하여 월별 데이터 가져오기 (캐시 우선, 없으면 DB에서 로드)
        monthly_data = get_monthly_data_with_cache(
            employee=self.request.user,
            year=str(current_date.year),
            month=str(current_date.month)
        )
        context['monthly_data'] = monthly_data
        context['form'] = MonthlyAttendanceForm()
        # monthly_data가 없어도 daily_form은 항상 제공
        # monthly_data가 없으면 disabled 폼 생성
        context['daily_form'] = DailyAttendanceForm(disabled=monthly_data is None)
        
        # 캘린더와 weekdays는 항상 생성 (monthly_data가 없어도)
        context['calendar'] = self.generate_calendar_data(current_date, monthly_data.daily_list if monthly_data else [])
        context['weekdays'] = ['日', '月', '火', '水', '木', '金', '土']

        # holidays_db: 3개월치(전월, 당월, 익월) 휴일 정보를 DB에서 가져와 context에 추가
        current_year = current_date.year
        current_month = current_date.month
        months = []
        for diff in [-1, 0, 1]:
            y = current_year + ((current_month + diff - 1) // 12)
            m = (current_month + diff - 1) % 12 + 1
            months.append((y, m))
        month_dates = []
        for y, m in months:
            last_day = calendar.monthrange(y, m)[1]
            for d in range(1, last_day + 1):
                month_dates.append(date(y, m, d))
        base_calendar = None
        if monthly_data:
            base_calendar = monthly_data.base_calendar
        calendars = ['共通']
        if base_calendar and base_calendar not in calendars:
            calendars.append(base_calendar)
        holidays = HolidayCalendar.objects.filter(calendar_name__in=calendars, date__in=month_dates)
        holidays_db = collections.defaultdict(list)
        for h in holidays:
            holidays_db[h.date].append({'calendar_name': h.calendar_name, 'category': h.category})
        holidays_db_strkey = {d.strftime('%Y-%m-%d'): v for d, v in holidays_db.items()}
        context['holidays_db'] = dict(holidays_db_strkey)
        context['holidays_db_json'] = json.dumps(holidays_db_strkey, ensure_ascii=False)

        # 리스트용 한 달치 날짜/요일 데이터 always 제공
        MonthDay = collections.namedtuple('MonthDay', ['date', 'weekday', 'record', 'is_holiday'])
        month_days = []
        cal = calendar.Calendar(firstweekday=6)  # 일요일 시작
        # 휴일 정보 준비
        holidays_set = set()
        for dstr in context['holidays_db'].keys():
            holidays_set.add(datetime.strptime(dstr, '%Y-%m-%d').date())
        for dt in cal.itermonthdates(current_date.year, current_date.month):
            if dt.month == current_date.month:
                # record: daily_list에서 해당 날짜가 있으면 연결, 없으면 None
                record = None
                if monthly_data and monthly_data.daily_list:
                    for d in monthly_data.daily_list:
                        if d.date == dt:
                            record = d
                            break
                # 토/일/휴일 판정
                is_holiday = (dt.weekday() == 6) or (dt.weekday() == 0) or (dt in holidays_set)
                month_days.append(MonthDay(date=dt, weekday=dt.weekday(), record=record, is_holiday=is_holiday))
        context['month_days_list'] = month_days

        # 인접 월 데이터 미리 로드
        preload_adjacent_months(self.request.user, current_date.year, current_date.month)

        # Employee 객체는 self.request.user
        employee = self.request.user

        # 전달 연/월 계산
        employee_no = self.request.user.employee_no
        if month == 1:
            prev_year, prev_month = year - 1, 12
        else:
            prev_year, prev_month = year, month - 1

        year = str(year)
        month = f"{int(month):02d}"
        prev_year = str(prev_year)
        prev_month = f"{int(prev_month):02d}"

        prev_monthly_data = AttendanceMonthly.objects.filter(
            employee__employee_no=employee_no, year=prev_year, month=prev_month
        ).first()

        context['prev_monthly_data'] = prev_monthly_data
        context['year'] = year
        context['month'] = month
    
        return context
    
    def generate_calendar_data(self, current_date, daily_list):
        import collections
        from django.utils.safestring import mark_safe
        # 구조체 기반 캘린더 데이터 생성
        cal = calendar.monthcalendar(current_date.year, current_date.month)
        daily_dict = {daily.date: daily for daily in daily_list}
        # holiday 정보 가져오기
        holidays_db = self.get_holidays_db(current_date)
        calendar_data = []
        for week in cal:
            week_data = []
            for day in week:
                if day == 0:
                    week_data.append({'date': None, 'record': None, 'holiday_category': []})
                else:
                    day_date = date(current_date.year, current_date.month, day)
                    record = daily_dict.get(day_date)
                    # holiday_category를 리스트로
                    holiday_category = [h['category'] for h in holidays_db.get(day_date, [])]
                    week_data.append({'date': day_date, 'record': record, 'holiday_category': holiday_category})
            calendar_data.append(week_data)
        return calendar_data

    def get_holidays_db(self, current_date):
        import collections
        from .models import HolidayCalendar
        current_year = current_date.year
        current_month = current_date.month
        months = []
        for diff in [-1, 0, 1]:
            y = current_year + ((current_month + diff - 1) // 12)
            m = (current_month + diff - 1) % 12 + 1
            months.append((y, m))
        month_dates = []
        for y, m in months:
            last_day = calendar.monthrange(y, m)[1]
            for d in range(1, last_day + 1):
                month_dates.append(date(y, m, d))
        calendars = ['共通']
        holidays = HolidayCalendar.objects.filter(calendar_name__in=calendars, date__in=month_dates)
        holidays_db = collections.defaultdict(list)
        for h in holidays:
            holidays_db[h.date].append({'calendar_name': h.calendar_name, 'category': h.category})
        return dict(holidays_db)

# 月別勤怠作成ビュー（ログイン必須）
class MonthlyAttendanceCreateView(LoginRequiredMixin, CreateView):
    model = AttendanceMonthly
    form_class = MonthlyAttendanceForm
    template_name = 'attendance/monthly_form.html'
    success_url = reverse_lazy('attendance:main')
    login_url = 'attendance:login'
    
    def form_valid(self, form):
        print("=== MonthlyAttendanceCreateView form_valid called ===")
        print(f"Request method: {self.request.method}")
        print(f"Request POST data: {self.request.POST}")
        
        form.instance.employee = self.request.user
        # URLパラメータから年月を取得
        year = self.request.POST.get('year')
        month = self.request.POST.get('month')
        print(f"Year: {year}, Month: {month}")
        
        if year and month:
            form.instance.year = str(year)
            form.instance.month = str(month).zfill(2)
            print(f"Set year: {form.instance.year}, month: {form.instance.month}")
        
        try:
            result = super().form_valid(form)
            print(f"Monthly attendance created successfully: {form.instance}")
            
            # AJAX 요청인 경우 JSON 응답
            if self.request.headers.get('X-Requested-With') == 'XMLHttpRequest':
                return JsonResponse({
                    'status': 'success',
                    'message': '月別情報が正常に登録されました。'
                })
            
            return result
        except Exception as e:
            print(f"Error creating monthly attendance: {e}")
            import traceback
            traceback.print_exc()
            
            # AJAX 요청인 경우 JSON 응답
            if self.request.headers.get('X-Requested-With') == 'XMLHttpRequest':
                return JsonResponse({
                    'status': 'error',
                    'message': f'登録中にエラーが発生しました: {str(e)}'
                })
            
            raise
    
    def form_invalid(self, form):
        print("=== MonthlyAttendanceCreateView form_invalid called ===")
        print(f"Form errors: {form.errors}")
        
        # AJAX 요청인 경우 JSON 응답
        if self.request.headers.get('X-Requested-With') == 'XMLHttpRequest':
            return JsonResponse({
                'status': 'error',
                'message': 'フォームの入力に問題があります。',
                'errors': form.errors
            })
        
        return super().form_invalid(form)

# 日別データ更新ビュー（ログイン必須）
@method_decorator(login_required, name='dispatch')
@method_decorator(csrf_exempt, name='dispatch')
class DailyDataUpdateView(View):
    def post(self, request, *args, **kwargs):
        print("=== DailyDataUpdateView called ===")
        print(f"Request method: {request.method}")
        print(f"Request content type: {request.content_type}")
        
        try:
            data = json.loads(request.body)
            print(f"Received data: {data}")
            
            # 日付の処理 - 日(day)のみを受け取り、現在の年月と組み合わせる
            day = data.get('day')
            if not day:
                print("Error: No day provided")
                return JsonResponse({'status': 'error', 'message': '日付が指定されていません'})
            
            year = data.get('year')
            month = data.get('month')
            
            if not year or not month:
                print("Error: No year or month provided")
                return JsonResponse({'status': 'error', 'message': '年月情報が不足しています'})
            
            print(f"Processing date: {year}-{month}-{day}")
            
            try:
                target_date = date(int(year), int(month), int(day))
                print(f"Target date: {target_date}")
            except ValueError as e:
                print(f"Date parsing error: {e}")
                return JsonResponse({'status': 'error', 'message': '無効な日付です'})
            
            # 구조체 기반으로 월별 데이터 가져오기
            monthly_data = get_or_create_monthly_structure(
                employee=request.user,
                year=str(target_date.year),
                month=str(target_date.month)
            )
            
            print(f"Monthly data found: {monthly_data is not None}")
            
            if not monthly_data:
                print("Error: No monthly data found")
                return JsonResponse({'status': 'error', 'message': '該当する月別勤怠情報が見つかりません'})
            
            # 필수 필드 검증
            work_type = data.get('work_type')
            start_time_str = data.get('start_time')
            end_time_str = data.get('end_time')
            alternative_work_date_str = data.get('alternative_work_date')
            
            if not work_type:
                return JsonResponse({'status': 'error', 'message': '勤務区分を選択してください'})
            
            if not start_time_str:
                return JsonResponse({'status': 'error', 'message': '作業開始時刻を入力してください'})
            
            if not end_time_str:
                return JsonResponse({'status': 'error', 'message': '作業終了時刻を入力してください'})
            
            print(f"Time strings: start={start_time_str}, end={end_time_str}, alt={alternative_work_date_str}")
            
            start_time = None
            end_time = None
            alternative_work_date = None
            
            if start_time_str:
                try:
                    start_time = datetime.strptime(start_time_str, '%H:%M').time()
                    print(f"Parsed start_time: {start_time}")
                except ValueError as e:
                    print(f"Start time parsing error: {e}")
                    pass
            
            if end_time_str:
                try:
                    end_time = datetime.strptime(end_time_str, '%H:%M').time()
                    print(f"Parsed end_time: {end_time}")
                except ValueError as e:
                    print(f"End time parsing error: {e}")
                    pass
            
            if alternative_work_date_str:
                try:
                    alternative_work_date = datetime.strptime(alternative_work_date_str, '%Y-%m-%d').date()
                    print(f"Parsed alternative_work_date: {alternative_work_date}")
                except ValueError as e:
                    print(f"Alternative work date parsing error: {e}")
                    pass
            
            # 기존 일별 데이터 찾기 또는 새로 생성
            existing_daily = None
            for daily in monthly_data.daily_list:
                if daily.date == target_date:
                    existing_daily = daily
                    break
            
            # 승인 대기/완료 상태면 수정 불가
            if existing_daily and (existing_daily.is_required or existing_daily.is_confirmed):
                return JsonResponse({'status': 'error', 'message': 'この日の勤怠情報は承認申請中または承認済みのため、修正できません。'})
            
            if existing_daily:
                # 기존 데이터 업데이트
                existing_daily.work_type = work_type  # 필수 필드이므로 기본값 없이 설정
                existing_daily.start_time = start_time  # 필수 필드이므로 기본값 없이 설정
                existing_daily.end_time = end_time  # 필수 필드이므로 기본값 없이 설정
                existing_daily.alternative_work_date = alternative_work_date or existing_daily.alternative_work_date
                existing_daily.notes = data.get('notes', existing_daily.notes)
                # 시간 계산 실행
                existing_daily.calculate_work_hours()
                print("Daily data updated")
                message = '更新しました'
            else:
                # 새 데이터 생성
                new_daily = DailyData(
                    date=target_date,
                    work_type=data.get('work_type', '出勤'),
                    start_time=start_time,
                    end_time=end_time,
                    alternative_work_date=alternative_work_date,
                    notes=data.get('notes', ''),
                    break_minutes=monthly_data.break_minutes,
                    standard_work_hours=monthly_data.standard_work_hours
                )
                # 시간 계산 실행
                new_daily.calculate_work_hours()
                monthly_data.daily_list.append(new_daily)
                print("Daily data created")
                message = '新規登録しました'
            
            # DB에 저장
            update_monthly_from_structure(monthly_data, request.user)
            
            # 캐시 무효화 (해당 월의 캐시 삭제)
            invalidate_monthly_cache(
                employee_id=request.user.employee_no,
                year=str(target_date.year),
                month=str(target_date.month)
            )
            
            print(f"Success: {message}")
            return JsonResponse({'status': 'success', 'message': message})
            
        except json.JSONDecodeError as e:
            print(f"JSON decode error: {e}")
            return JsonResponse({'status': 'error', 'message': 'JSONデータの解析に失敗しました'})
        except Exception as e:
            print(f"Unexpected error: {e}")
            import traceback
            traceback.print_exc()
            return JsonResponse({'status': 'error', 'message': str(e)})

# 日別データ取得ビュー（ログイン必須）
@method_decorator(login_required, name='dispatch')
class DailyDataGetView(View):
    def get(self, request, *args, **kwargs):
        date_str = request.GET.get('date')
        if not date_str:
            return JsonResponse({'status': 'error', 'message': '日付が指定されていません'})
        
        try:
            target_date = datetime.strptime(date_str, '%Y-%m-%d').date()
            
            # 구조체 기반으로 월별 데이터 가져오기
            monthly_data = get_or_create_monthly_structure(
                employee=request.user,
                year=str(target_date.year),
                month=str(target_date.month)
            )
            
            if not monthly_data:
                return JsonResponse({'status': 'success', 'record': None})
            
            # 해당 날짜의 일별 데이터 찾기
            daily_data = None
            for daily in monthly_data.daily_list:
                if daily.date == target_date:
                    daily_data = daily
                    break
            
            if daily_data:
                record = {
                    'work_type': daily_data.work_type,
                    'start_time': daily_data.start_time.strftime('%H:%M') if daily_data.start_time else '',
                    'end_time': daily_data.end_time.strftime('%H:%M') if daily_data.end_time else '',
                    'alternative_work_date': daily_data.alternative_work_date.strftime('%Y-%m-%d') if daily_data.alternative_work_date else '',
                    'notes': daily_data.notes or ''
                }
                return JsonResponse({'status': 'success', 'record': record})
            else:
                return JsonResponse({'status': 'success', 'record': None})
                
        except ValueError:
            return JsonResponse({'status': 'error', 'message': '無効な日付形式です'})
        except Exception as e:
            return JsonResponse({'status': 'error', 'message': str(e)})

# 月別勤怠削除ビュー（ログイン必須）
@method_decorator(login_required, name='dispatch')
@method_decorator(csrf_exempt, name='dispatch')
class MonthlyAttendanceDeleteView(View):
    def post(self, request, *args, **kwargs):
        print("=== MonthlyAttendanceDeleteView called ===")
        try:
            data = json.loads(request.body)
            year = data.get('year')
            month = data.get('month')
            
            print(f"Deleting monthly attendance for year: {year}, month: {month}")
            
            if not year or not month:
                return JsonResponse({'status': 'error', 'message': '年月情報が不足しています'})
            
            # 구조체 기반으로 월별 데이터 가져오기
            monthly_data = get_or_create_monthly_structure(
                employee=request.user,
                year=str(year),
                month=str(month)
            )
            
            if not monthly_data:
                return JsonResponse({'status': 'error', 'message': '該当する月別勤怠情報が見つかりません'})
            
            # DB에서 삭제
            monthly_model = AttendanceMonthly.objects.filter(
                employee=request.user,
                year=str(year),
                month=str(month).zfill(2)
            ).first()
            
            if monthly_model:
                # 관련하는 일별 데이터도 삭제
                daily_count = AttendanceDaily.objects.filter(monthly_attendance=monthly_model).count()
                AttendanceDaily.objects.filter(monthly_attendance=monthly_model).delete()
                
                # 월별 데이터를 삭제
                monthly_model.delete()
                
                print(f"Deleted monthly attendance and {daily_count} daily records")
            
            # 캐시 무효화 (해당 월의 캐시 삭제)
            invalidate_monthly_cache(
                employee_id=request.user.employee_no,
                year=str(year),
                month=str(month)
            )
            
            return JsonResponse({
                'status': 'success', 
                'message': f'{year}年{month}月の勤怠情報を削除しました。'
            })
            
        except json.JSONDecodeError as e:
            print(f"JSON decode error: {e}")
            return JsonResponse({'status': 'error', 'message': 'JSONデータの解析に失敗しました'})
        except Exception as e:
            print(f"Unexpected error: {e}")
            import traceback
            traceback.print_exc()
            return JsonResponse({'status': 'error', 'message': str(e)})

# 日別勤怠削除ビュー（ログイン必須）
@method_decorator(login_required, name='dispatch')
@method_decorator(csrf_exempt, name='dispatch')
class DailyAttendanceDeleteView(View):
    def post(self, request, *args, **kwargs):
        print("=== DailyAttendanceDeleteView called ===")
        try:
            data = json.loads(request.body)
            date_str = data.get('date')
            
            if not date_str:
                return JsonResponse({'status': 'error', 'message': '日付が指定されていません'})
            
            try:
                target_date = datetime.strptime(date_str, '%Y-%m-%d').date()
            except ValueError:
                return JsonResponse({'status': 'error', 'message': '無効な日付形式です'})
            
            # 구조체 기반으로 월별 데이터 가져오기
            monthly_data = get_or_create_monthly_structure(
                employee=request.user,
                year=str(target_date.year),
                month=str(target_date.month)
            )
            
            if not monthly_data:
                return JsonResponse({'status': 'error', 'message': '該当する月別勤怠情報が見つかりません'})
            
            # 해당 날짜의 일별 데이터 찾기 및 제거
            daily_to_remove = None
            for daily in monthly_data.daily_list:
                if daily.date == target_date:
                    daily_to_remove = daily
                    break
            
            if daily_to_remove:
                monthly_data.daily_list.remove(daily_to_remove)
                
                # DB에서도 삭제
                monthly_model = AttendanceMonthly.objects.filter(
                    employee=request.user,
                    year=str(target_date.year),
                    month=str(target_date.month).zfill(2)
                ).first()
                
                if monthly_model:
                    AttendanceDaily.objects.filter(
                        monthly_attendance=monthly_model,
                        date=target_date
                    ).delete()
                
                # 구조체를 DB에 저장
                update_monthly_from_structure(monthly_data, request.user)
                
                # 캐시 무효화 (해당 월의 캐시 삭제)
                invalidate_monthly_cache(
                    employee_id=request.user.employee_no,
                    year=str(target_date.year),
                    month=str(target_date.month)
                )
                
                return JsonResponse({
                    'status': 'success', 
                    'message': f'{target_date.strftime("%Y年%m月%d日")}の勤怠情報を削除しました。'
                })
            else:
                return JsonResponse({'status': 'error', 'message': '該当する日別勤怠情報が見つかりません'})
                
        except json.JSONDecodeError as e:
            print(f"JSON decode error: {e}")
            return JsonResponse({'status': 'error', 'message': 'JSONデータの解析に失敗しました'})
        except Exception as e:
            print(f"Unexpected error: {e}")
            import traceback
            traceback.print_exc()
            return JsonResponse({'status': 'error', 'message': str(e)})

# 月別勤怠修正ビュー（ログイン必須）
@method_decorator(login_required, name='dispatch')
@method_decorator(csrf_exempt, name='dispatch')
class MonthlyAttendanceUpdateView(View):
    def post(self, request, *args, **kwargs):
        print("=== MonthlyAttendanceUpdateView called ===")
        try:
            data = json.loads(request.body)
            year = data.get('year')
            month = data.get('month')
            
            print(f"Updating monthly attendance for year: {year}, month: {month}")
            print(f"Update data: {data}")
            
            if not year or not month:
                return JsonResponse({'status': 'error', 'message': '年月情報が不足しています'})
            
            # 구조체 기반으로 월별 데이터 가져오기
            monthly_data = get_or_create_monthly_structure(
                employee=request.user,
                year=str(year),
                month=str(month)
            )
            
            if not monthly_data:
                return JsonResponse({'status': 'error', 'message': '該当する月別勤怠情報が見つかりません'})
            
            # 구조체 데이터 업데이트
            monthly_data.project_name = data.get('project_name', monthly_data.project_name)
            monthly_data.base_calendar = data.get('base_calendar', monthly_data.base_calendar)
            monthly_data.break_minutes = int(data.get('break_minutes', monthly_data.break_minutes))
            monthly_data.standard_work_hours = float(data.get('standard_work_hours', monthly_data.standard_work_hours))
            
            # 일별 데이터의 설정값도 업데이트
            for daily in monthly_data.daily_list:
                daily.break_minutes = monthly_data.break_minutes
                daily.standard_work_hours = monthly_data.standard_work_hours
                # 시간 재계산
                daily.calculate_work_hours()
            
            # DB에 저장
            update_monthly_from_structure(monthly_data, request.user)
            
            # 캐시 무효화 (해당 월의 캐시 삭제)
            invalidate_monthly_cache(
                employee_id=request.user.employee_no,
                year=str(year),
                month=str(month)
            )
            
            print(f"Monthly data updated successfully")
            
            return JsonResponse({
                'status': 'success', 
                'message': f'{year}年{month}月の勤怠情報を修正しました。'
            })
            
        except json.JSONDecodeError as e:
            print(f"JSON decode error: {e}")
            return JsonResponse({'status': 'error', 'message': 'JSONデータの解析に失敗しました'})
        except Exception as e:
            print(f"Unexpected error: {e}")
            import traceback
            traceback.print_exc()
            return JsonResponse({'status': 'error', 'message': str(e)})

# エクセルダウンロードビュー（ログイン必須）
@method_decorator(login_required, name='dispatch')
class ExcelDownloadView(View):
    def get(self, request, *args, **kwargs):
        # URLパラメータから年月を取得
        year = request.GET.get('year')
        month = request.GET.get('month')
        
        if not year or not month:
            return JsonResponse({'status': 'error', 'message': '年月が指定されていません'})
        
        try:
            # ExcelReportGeneratorを使用してエクセルファイルを生成
            generator = ExcelReportGenerator(request.user, int(year), int(month))
            workbook = generator.generate_report()
            
            # ファイル名を生成
            employee_name = request.user.display_name or request.user.employee_no
            filename = f"{year}_{month}_稼動報告書_{employee_name}.xlsx"
            
            # レスポンスを作成
            response = HttpResponse(
                content_type='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
            )
            response['Content-Disposition'] = f'attachment; filename="{filename}"'
            
            # 엑셀 저장 직전
            print("엑셀 저장 직전")
            workbook.save(response)
            print("엑셀 저장 성공")
            return response
            
        except ValueError as e:
            print(f"ValueError in Excel download: {e}")
            return JsonResponse({'status': 'error', 'message': str(e)})
        except Exception as e:
            print(f"Error creating Excel file: {e}")
            return JsonResponse({'status': 'error', 'message': f'エクセルファイルの作成中にエラーが発生しました: {str(e)}'})

# PDF 미리보기 뷰（ログイン必須）
@method_decorator(login_required, name='dispatch')
class PDFPreviewView(View):
    def get(self, request, *args, **kwargs):
        # URLパラメータから年月を取得
        year = request.GET.get('year')
        month = request.GET.get('month')
        
        if not year or not month:
            return JsonResponse({'status': 'error', 'message': '年月が指定されていません'})
        
        try:
            # PDFReportGeneratorを使用してPDFファイルを生成
            generator = PDFReportGenerator(request.user, int(year), int(month))
            pdf_buffer = generator.generate_pdf()
            
            # ファイル名を生成
            employee_name = request.user.display_name or request.user.employee_no
            filename = f"{year}_{month}_稼動報告書_{employee_name}.pdf"
            
            # レスポンスを作成
            response = HttpResponse(
                content_type='application/pdf'
            )
            
            response['Content-Disposition'] = f'attachment; filename="{filename}"'
            
            # iframe에서 표시할 수 있도록 X-Frame-Options 헤더 설정
            response['X-Frame-Options'] = 'SAMEORIGIN'
            
            # PDFデータをレスポンスに書き込み
            response.write(pdf_buffer.getvalue())
            return response
            
        except ValueError as e:
            print(f"ValueError in PDF preview: {e}")
            return JsonResponse({'status': 'error', 'message': str(e)})
        except Exception as e:
            print(f"Error creating PDF file: {e}")
            return JsonResponse({'status': 'error', 'message': f'PDFファイルの作成中にエラーが発生しました: {str(e)}'})

@method_decorator(csrf_exempt, name='dispatch')
class EmailSendView(View):
    def post(self, request, *args, **kwargs):
        import json
        try:
            data = json.loads(request.body)
            email_to = data.get('email')
            file_type = data.get('file_type')
            year = data.get('year')
            month = data.get('month')
            if not email_to or not file_type or not year or not month:
                return JsonResponse({'status': 'error', 'message': '必要な情報が不足しています。'})
            # 파일 생성
            if file_type == 'pdf':
                from .pdf_generator import PDFReportGenerator
                generator = PDFReportGenerator(request.user, int(year), int(month))
                file_buffer = generator.generate_pdf()
                file_ext = 'pdf'
                mime_type = 'application/pdf'
            elif file_type == 'excel':
                generator = ExcelReportGenerator(request.user, int(year), int(month))
                workbook = generator.generate_report()
                file_buffer = tempfile.NamedTemporaryFile(delete=False, suffix='.xlsx')
                try:
                    print("엑셀 저장 직전")
                    workbook.save(file_buffer.name)
                    print("엑셀 저장 성공")
                except Exception as e:
                    print("엑셀 저장 중 에러:", e)
                file_ext = 'xlsx'
                mime_type = 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
            else:
                return JsonResponse({'status': 'error', 'message': 'ファイル種別が不正です。'})
            # 메일 전송
            subject = f"{year}年{month}月 稼働報告書"
            body = f"{year}年{month}月の稼働報告書を添付します。"
            email = EmailMessage(
                subject=subject,
                body=body,
                from_email=None,  # settings.DEFAULT_FROM_EMAIL 사용
                to=[email_to],
            )
            employee_name = request.user.display_name or request.user.employee_no
            if file_type == 'pdf':
                filename = f"{year}_{month}_稼働報告書_{employee_name}.pdf"
                email.attach(filename, file_buffer.getvalue(), mime_type)
            else:
                filename = f"{year}_{month}_稼働報告書_{employee_name}.xlsx"
                file_buffer.seek(0)
                email.attach(filename, file_buffer.read(), mime_type)
            email.send()
            # 임시파일 정리
            if file_type == 'excel':
                import os
                file_buffer.close()
                os.unlink(file_buffer.name)
            return JsonResponse({'status': 'success'})
        except Exception as e:
            import traceback
            traceback.print_exc()
            return JsonResponse({'status': 'error', 'message': f'送信中にエラーが発生しました: {str(e)}'})

class PasswordChangeForm(forms.Form):
    old_password = forms.CharField(label='現在のパスワード', widget=forms.PasswordInput)
    new_password1 = forms.CharField(label='新しいパスワード', widget=forms.PasswordInput)
    new_password2 = forms.CharField(label='新しいパスワード（確認）', widget=forms.PasswordInput)

    def __init__(self, user, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.user = user

    def clean_old_password(self):
        old_password = self.cleaned_data.get('old_password')
        if not self.user.check_password(old_password):
            raise forms.ValidationError('現在のパスワードが正しくありません。')
        return old_password

    def clean(self):
        cleaned_data = super().clean()
        pw1 = cleaned_data.get('new_password1')
        pw2 = cleaned_data.get('new_password2')
        if pw1 and pw2 and pw1 != pw2:
            raise forms.ValidationError('新しいパスワードが一致しません。')
        return cleaned_data

@login_required
def password_change_view(request):
    if request.method == 'POST':
        form = PasswordChangeForm(request.user, request.POST)
        if form.is_valid():
            request.user.set_password(form.cleaned_data['new_password1'])
            request.user.save()
            update_session_auth_hash(request, request.user)
            messages.success(request, 'パスワードを変更しました。再度ログインしてください。')
            return redirect('attendance:login')
    else:
        form = PasswordChangeForm(request.user)
    return render(request, 'attendance/password_change.html', {'form': form})

def signup_view(request):
    if request.method == 'POST':
        form = SignupForm(request.POST)
        if form.is_valid():
            employee_no = form.cleaned_data['employee_no']
            password = form.cleaned_data['password']
            if Employee.objects.filter(employee_no=employee_no).exists():
                messages.error(request, 'この社員番号は既に登録されています。')
            else:
                user = Employee(employee_no=employee_no)
                user.set_password(password)
                user.save()
                messages.success(request, 'ユーザー登録が完了しました。ログインしてください。')
                return redirect('/')
    else:
        form = SignupForm()
    return render(request, 'attendance/signup.html', {'form': form})

@require_POST
@login_required
def copy_prev_month(request):
    employee_no = request.user.employee_no  # 로그인한 사원번호
    year = int(request.POST.get('year'))
    month = int(request.POST.get('month'))

    # 전월 계산
    if month == 1:
        prev_year, prev_month = year - 1, 12
    else:
        prev_year, prev_month = year, month - 1

    # 모두 문자열로 변환
    year = str(year)
    month = f"{int(month):02d}"
    prev_year = str(prev_year)
    prev_month = f"{int(prev_month):02d}"

    print("employee_no:", employee_no)
    print("prev_year:", prev_year)
    print("prev_month:", prev_month)
    print("DB rows:", AttendanceMonthly.objects.filter(employee__employee_no=employee_no).values('year', 'month'))

    try:
        prev_obj = AttendanceMonthly.objects.get(
            employee__employee_no=employee_no, year=prev_year, month=prev_month
        )
    except AttendanceMonthly.DoesNotExist:
        return HttpResponseBadRequest('前月の情報がありません。')

    if AttendanceMonthly.objects.filter(employee__employee_no=employee_no, year=year, month=month).exists():
        return HttpResponseBadRequest('今月の情報は既に存在します。')

    # Employee 객체 가져오기
    employee = request.user

    new_obj = AttendanceMonthly(
        employee=employee,
        year=year,
        month=month,
        project_name=prev_obj.project_name,
        base_calendar=prev_obj.base_calendar,
        break_minutes=prev_obj.break_minutes,
        standard_work_hours=prev_obj.standard_work_hours,
        is_confirmed=False,
        is_required=False,
    )
    new_obj.save()

    return JsonResponse({'result': 'ok'})

@method_decorator(login_required, name='dispatch')
@method_decorator(csrf_exempt, name='dispatch')
class DailyApproveView(View):
    def post(self, request, *args, **kwargs):
        import json
        try:
            data = json.loads(request.body)
            date_str = data.get('date')
            if not date_str:
                return JsonResponse({'status': 'error', 'message': '日付が指定されていません'})
            try:
                target_date = datetime.strptime(date_str, '%Y-%m-%d').date()
            except ValueError:
                return JsonResponse({'status': 'error', 'message': '無効な日付形式です'})
            # 월별 데이터 가져오기
            monthly_data = get_or_create_monthly_structure(
                employee=request.user,
                year=str(target_date.year),
                month=str(target_date.month)
            )
            if not monthly_data:
                return JsonResponse({'status': 'error', 'message': '該当する月別勤怠情報が見つかりません'})
            # 해당 날짜의 일별 데이터 찾기
            daily_data = None
            for daily in monthly_data.daily_list:
                if daily.date == target_date:
                    daily_data = daily
                    break
            if not daily_data:
                return JsonResponse({'status': 'error', 'message': '該当する日別勤怠情報が見つかりません'})
            if daily_data.is_required == 1:
                return JsonResponse({'status': 'error', 'message': 'すでに承認申請中です。'})
            daily_data.is_required = 1
            update_monthly_from_structure(monthly_data, request.user)
            invalidate_monthly_cache(
                employee_id=request.user.employee_no,
                year=str(target_date.year),
                month=str(target_date.month)
            )
            return JsonResponse({'status': 'success', 'message': '承認申請しました。'})
        except Exception as e:
            import traceback
            traceback.print_exc()
            return JsonResponse({'status': 'error', 'message': str(e)})

